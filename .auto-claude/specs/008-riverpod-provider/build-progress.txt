=== AUTO-BUILD PROGRESS ===

Project: 优化Riverpod Provider生命周期管理，减少不必要的内存常驻
Workspace: E:\Aaalice_NAI_Launcher\.auto-claude\worktrees\tasks\008-riverpod-provider
Started: 2026-02-16

Workflow Type: refactor
Rationale: 这是一个重构任务，需要逐步审查和修改现有Provider的keepAlive策略，同时确保功能不中断。采用分阶段迁移策略：分析→修改→验证→清理。

Session 1 (Planner):
- Created implementation_plan.json
- Phases: 9
- Total subtasks: 32
- Created context.json
- Created init.sh

Phase Summary:
- Phase 1 (分析阶段 - Provider分类与评估): 3 subtasks, depends on []
- Phase 2 (页面级Provider优化): 5 subtasks, depends on [phase-1-analysis]
- Phase 3 (设置类Provider优化): 6 subtasks, depends on [phase-1-analysis]
- Phase 4 (生成相关Provider优化): 5 subtasks, depends on [phase-1-analysis]
- Phase 5 (队列相关Provider评估): 3 subtasks, depends on [phase-1-analysis]
- Phase 6 (核心Provider评估): 5 subtasks, depends on [phase-1-analysis]
- Phase 7 (Service层Provider优化): 2 subtasks, depends on [phase-1-analysis]
- Phase 8 (代码生成与验证): 3 subtasks, depends on [phase-2,3,4,5,6,7]
- Phase 9 (文档与清理): 2 subtasks, depends on [phase-8-generation]

Services Involved:
- frontend: Flutter application with Riverpod state management

Provider Statistics:
- Total keepAlive providers found: 63
- Presentation layer: 42 providers
- Data/core service layer: 21 providers
- Planned removals: 12 providers
- Planned retentions: 51 providers

Parallelism Analysis:
- Max parallel phases: 3
- Recommended workers: 2
- Parallel groups:
  * phase-2-page-providers, phase-3-settings-providers, phase-6-core-providers
    (These modify different provider files with no conflicts)

Categorization Strategy:
1. Core (keep): auth_provider, account_manager_provider, image_generation_provider
2. PageState (remove): tag_library_page_provider, bulk_operation_provider, character_prompt_provider
3. Service (keep): All data/services and core/services providers
4. Cache (conditional): data_source_cache_provider - evaluate case by case
5. Queue (keep): queue_execution_provider, replication_queue_provider

Verification Strategy:
- Risk level: medium
- Test types: static_analysis only
- No unit/integration/E2E tests required
- Primary verification: flutter analyze + build_runner

Key Files to Modify:
1. lib/presentation/providers/tag_library_page_provider.dart
2. lib/presentation/providers/bulk_operation_provider.dart
3. lib/presentation/providers/character_prompt_provider.dart
4. lib/presentation/providers/collection_provider.dart
5. lib/presentation/providers/notification_settings_provider.dart
6. lib/presentation/providers/quality_preset_provider.dart
7. lib/presentation/providers/uc_preset_provider.dart
8. lib/presentation/providers/random_preset_provider.dart
9. lib/presentation/providers/generation/reference_panel_notifier.dart

Files to Reference (Patterns):
- lib/presentation/providers/auth_provider.dart
- lib/presentation/providers/queue_execution_provider.dart
- lib/presentation/providers/tag_library_provider.dart
- lib/presentation/providers/image_generation_provider.dart

=== STARTUP COMMAND ===

To continue building this spec:

1. Run init.sh to setup environment:
   bash .auto-claude/specs/008-riverpod-provider/init.sh

2. Then start implementation with the coder agent

=== END SESSION 1 ===

---

## Subtask 2-2: 优化tag_library_provider - 评估是否保留keepAlive

### 评估结论
**决定：保留 keepAlive: true**

理由：
1. **核心数据 Provider** - 词库数据在多个功能模块中被频繁使用（生成页标签建议、词库管理页等）
2. **初始化成本高** - 需要加载和解析大型 JSON 文件，重新加载会造成明显延迟
3. **内存占用合理** - 词库数据是应用核心功能所需，保持常驻内存的收益大于成本

### 修改内容
- 添加了详细的文档注释，说明保留 keepAlive 的理由

### 状态
✅ 已完成 - 2026-02-16

---

## Subtask 3-2: 优化image_save_settings_provider - 保留keepAlive

### 评估结论
**决定：保留 keepAlive: true**

理由：
1. **全局功能** - 图片保存设置在整个应用生命周期中需要被访问
2. **后台使用** - 图像生成完成后的自动保存操作需要访问此设置
3. **跨页面访问** - 在设置页面、生成页面等多个页面中共享使用
4. **状态一致性** - 自动保存开关状态需要在整个应用中保持一致
5. **内存收益** - 仅存储简单配置（路径字符串和布尔值），内存占用极小

### 修改内容
- 添加了详细的文档注释（9行），说明保留 keepAlive 的理由和具体场景

### 提交信息
```
auto-claude: subtask-3-2 - 优化image_save_settings_provider - 保留keepAlive
```

### 状态
✅ 已完成 - 2026-02-16

---

## Subtask 3-5: 优化uc_preset_provider - 移除keepAlive

### 修改内容
**文件**: `lib/presentation/providers/uc_preset_provider.dart`

**变更**:
- 将 `@Riverpod(keepAlive: true)` 改为 `@Riverpod()`
- 允许UC预设Provider在页面关闭后自动清理

### 理由
1. **状态持久化** - 所有状态通过 LocalStorage 持久化存储，无需 keepAlive 保持
2. **页面级状态** - UC预设主要在设置页面和生成页面使用，不需要全局常驻
3. **自动恢复** - build() 方法从 LocalStorage 加载状态，重新访问时自动恢复
4. **内存优化** - 页面关闭后自动释放内存，减少不必要的内存占用

### 提交信息
```
auto-claude: subtask-3-5 - 优化uc_preset_provider - 移除keepAlive
```

### 注意
- 需要运行 `dart run build_runner build --delete-conflicting-outputs` 重新生成 .g.dart 文件
- 相关依赖项 `currentUcEntry` 和 `ucCustomEntries` 使用 `@riverpod` 注解，会自动跟随主Provider的生命周期

### 状态
✅ 已完成 - 2026-02-16

---

## Subtask 4-3: 评估image_generation_provider - 保留keepAlive

### 评估结论
**决定：保留 keepAlive: true** - 无需修改

理由：
1. **长时运行操作** - 图像生成需要秒到分钟，用户可能导航离开并返回，期望看到进度/结果
2. **状态价值** - 持有生成的图像数据(Uint8List)、历史记录(最多50张)、流式预览和进度跟踪
3. **用户体验影响** - 如果被dispose，生成的图像会消失，流式预览丢失，生成历史被清除 - 不可接受的UX
4. **状态类型** - "活跃工作状态" - 持有用户发起的操作结果，应该持久化

### 管理的状态 (ImageGenerationState)

- `GenerationStatus status` - idle/generating/completed/error/cancelled
- `List<GeneratedImage> currentImages` - 当前批次结果
- `List<GeneratedImage> history` - 最近50张生成的图像
- `Uint8List? streamPreview` - 生成过程中的渐进式预览
- `List<GeneratedImage> displayImages` - 中央显示区域图像
- `double progress` - 0.0 到 1.0
- `currentImage/totalImages` - 进度跟踪

### 关键方法

- `generate(ImageParams)` - 启动生成，包含重试逻辑、批处理、自动保存
- `cancel()` - 取消正在进行的生成
- `_generateBatchWithStream()` - 带流式预览的核心生成
- `generateAndApplyRandomPrompt()` - 随机提示词生成（"抽卡模式"）

### 结论

这是Riverpod中`keepAlive`的典型用例 - 代表：
1. 活跃/进行中的工作
2. 重要的用户生成数据
3. 应该 survived 导航和UI重建的状态
4. 长时间运行操作状态管理

**状态**: 已验证，无需代码修改。

### 提交信息
```
auto-claude: subtask-4-3 - 评估image_generation_provider - 保留keepAlive
```

### 状态
✅ 已完成 - 2026-02-16

---

## Subtask 6-1: 评估auth_provider - 保留keepAlive

### 评估结论
**决定：保留 keepAlive: true** - 无需修改

理由：
1. **核心认证状态** - 管理全局认证状态(AuthState)，包含status、accountId、subscriptionInfo等，整个应用生命周期都需要
2. **App启动自动登录** - _checkExistingAuth()在build时异步执行，验证存储的token并尝试自动登录，这是一次性的初始化操作
3. **跨页面状态** - 认证状态被几乎所有需要API调用的页面和Provider依赖，需要全局保持
4. **Token管理** - 处理access token的验证、存储和刷新，是安全敏感操作
5. **多账号支持** - 支持账号切换和多个保存账号的自动登录

### 管理的状态 (AuthState)

- `AuthStatus status` - initial/loading/authenticated/unauthenticated/error
- `String? accountId` - 当前登录账号ID
- `String? displayName` - 显示名称
- `Map<String, dynamic>? subscriptionInfo` - 订阅信息（含Anlas余额）
- `AuthErrorCode? errorCode` - 错误码（网络/认证/服务器等）

### 关键方法

- `_checkExistingAuth()` - 启动时检查存储的token并尝试自动登录
- `loginWithToken()` - 使用Persistent Token登录
- `loginWithCredentials()` - 使用邮箱密码登录
- `switchAccount()` - 切换已保存的账号
- `logout()` - 登出并清除认证状态
- `retryAutoLogin()` - 网络恢复后重试自动登录

### Provider结构

```dart
@Riverpod(keepAlive: true)  // ✅ 正确，需要全局保持
class AuthNotifier extends _$AuthNotifier {
  @override
  AuthState build() {
    _checkExistingAuth();  // 异步自动登录检查
    return const AuthState(status: AuthStatus.loading);
  }
  // ...
}
```

### 结论

这是Riverpod中`keepAlive`的典型用例：
- 全局应用状态 - 认证状态需要在整个应用生命周期保持
- 一次性初始化 - 启动时执行的自动登录检查不应重复
- 跨页面共享 - 多个页面和Provider依赖此状态
- 安全敏感 - Token管理和验证需要一致的状态

**状态**: 已验证，当前配置正确，无需代码修改。

### 提交信息
```
auto-claude: subtask-6-1 - 评估auth_provider - 保留keepAlive
```

### 状态
✅ 已完成 - 2026-02-16

---

## Subtask 6-3: 评估local_gallery_provider - 保留keepAlive

### 评估结论
**决定：保留 keepAlive: true** - 无需修改

理由：
1. **StatefulShellRoute保活页面** - 本地画廊是应用路由架构中的"保活页面"之一（与onlineGallery一起），使用Offstage保持状态，用户切换标签页时期望状态保持
2. **昂贵的后台操作** - 执行后台文件扫描和索引(`_initializeInBackground()`)，如果被dispose后重建，这些昂贵操作需要重新开始
3. **大量状态管理** - 管理可能成千上万的图像文件(`allFiles`, `filteredFiles`)、元数据记录和分页状态，重复创建效率低下
4. **用户状态持久化** - 用户期望滚动位置、过滤器、搜索查询和扫描进度在导航离开并返回时保持不变
5. **单例仓库模式** - 使用`LocalGalleryRepository.instance`单例，Provider生命周期应与仓库生命周期匹配
6. **跨功能依赖** - 画廊状态被多个功能访问（Vibe Transfer图像选择、批量操作等）

### 管理的状态 (LocalGalleryState)

- `List<File> allFiles` - 所有图像文件
- `List<File> filteredFiles` - 过滤后的文件列表
- `List<LocalImageRecord> currentImages` - 当前页图像记录（含元数据）
- `String searchQuery` - 搜索关键词
- `double? backgroundScanProgress` - 后台扫描进度
- `String? scanPhase` - 扫描阶段（checking/indexing/completed）
- 多种过滤器：日期、收藏、Vibe、标签、模型、采样器等

### 关键方法

- `initialize()` - 初始化画廊，立即显示文件列表，后台扫描索引
- `_initializeInBackground()` - 后台扫描索引，不阻塞UI
- `loadPage()` - 分页加载图像记录
- `refresh()` - 增量扫描刷新
- `performFullScan()` - 全量重建索引
- `_applyFilters()` - 应用搜索和过滤条件

### Provider结构

```dart
@Riverpod(keepAlive: true)  // ✅ 正确，需要全局保持
class LocalGalleryNotifier extends _$LocalGalleryNotifier {
  late final LocalGalleryRepository _repo;

  @override
  LocalGalleryState build() {
    _repo = LocalGalleryRepository.instance;
    return const LocalGalleryState();
  }
  // ...
}
```

### 结论

这是Riverpod中`keepAlive`的典型用例：
- 保活页面状态 - 路由架构要求页面保持存活
- 昂贵的后台操作 - 扫描和索引不应被中断
- 大量状态缓存 - 文件列表和元数据重建成本高
- 用户体验 - 状态应在整个应用会话中持续

**状态**: 已验证，当前配置正确，无需代码修改。

### 提交信息
```
auto-claude: subtask-6-3 - 评估local_gallery_provider - 保留keepAlive
```

### 状态
✅ 已完成 - 2026-02-16

---

## Subtask 6-2: 评估account_manager_provider - 保留keepAlive

### 评估结论
**决定：保留 keepAlive: true** - 无需修改

理由：
1. **App-wide Core Service** - 账号管理是跨应用的核心服务，多个Provider和UI组件依赖它进行认证
2. **状态持久化** - 从Hive加载账号列表，管理SecureStorage中的敏感token，频繁的dispose/recreate会造成不必要的I/O开销
3. **多账号支持** - 管理所有用户账号，包括默认账号设置、最后使用时间跟踪等，需要全局状态保持一致
4. **Singleton Pattern** - 作为单例服务管理应用级认证状态，需要在整个应用生命周期保持可用
5. **跨依赖需求** - 其他Provider（如auth_provider）依赖此Provider进行账号相关操作

### 管理的状态 (AccountManagerState)

- `List<SavedAccount> accounts` - 保存的账号列表
- `bool isLoading` - 加载状态
- `String? error` - 错误信息

### 关键方法

- `_loadAccounts()` - 从Hive加载账号列表
- `addAccount()` - 添加新账号（支持Token和Credentials两种类型）
- `removeAccount()` - 删除账号并清理存储的token
- `setDefaultAccount()` - 设置默认账号
- `getAccountToken()` - 从SecureStorage获取账号token
- `defaultAccount` getter - 获取最近使用的默认账号
- `sortedAccounts` getter - 按最后使用时间排序的账号列表

### Provider结构

```dart
@Riverpod(keepAlive: true)  // ✅ 正确，需要全局保持
class AccountManagerNotifier extends _$AccountManagerNotifier {
  @override
  AccountManagerState build() {
    _loadAccounts();  // 异步加载保存的账号
    return const AccountManagerState(isLoading: true);
  }
  // ...
}
```

### 存储架构

- **Hive**: 存储账号列表（非敏感数据）
- **SecureStorage**: 存储各账号的access token和access key（敏感数据）

### 结论

这是Riverpod中`keepAlive`的典型用例：
- 核心服务 - 账号管理是应用基础设施，需要全局可用
- 初始化成本 - 需要从存储加载数据，应保持缓存
- 跨组件依赖 - 多个页面和Provider共享访问
- 稳定性要求 - 账号数据相对稳定，dispose收益不明显

**状态**: 已验证，当前配置正确，无需代码修改。

### 提交信息
```
auto-claude: subtask-6-2 - 评估account_manager_provider - 保留keepAlive
```

### 状态
✅ 已完成 - 2026-02-16

---

## Subtask 6-4: 评估vibe_library_provider - 保留keepAlive

### 评估结论
**决定：保留 keepAlive: true** - 无需修改

理由：
1. **App-wide Service Nature** - VibeLibraryNotifier管理整个Vibe库，这是一个持久的用户数据仓库，类似于本地数据库，管理条目、分类、搜索过滤、排序和分页状态
2. **状态持久化要求** - 用户期望在离开并返回Vibe库时，搜索查询、分页位置、过滤器设置保持不变
3. **性能考虑** - 从VibeLibraryStorageService加载数据需要I/O操作，如果没有keepAlive，每次导航离开再返回时都需要重新加载，造成不必要的开销
4. **复杂操作支持** - 支持长时间运行的批量操作（删除、导出、移动、标签编辑），这些操作不应因导航而中断
5. **单例模式** - 代码中的`initialize()`已有守卫逻辑防止重复加载，表明设计上预期为长期存在的Provider

### 管理的状态 (VibeLibraryState)

- `List<VibeLibraryEntry> entries` - 所有条目
- `List<VibeLibraryEntry> filteredEntries` - 过滤后的条目
- `List<VibeLibraryCategory> categories` - 所有分类
- `List<VibeLibraryEntry> currentEntries` - 当前页显示的条目
- `String searchQuery` - 搜索关键词
- `String? selectedCategoryId` - 选中的分类ID
- `bool favoritesOnly` - 是否只显示收藏
- `VibeLibrarySortOrder sortOrder` - 排序方式
- `bool sortDescending` - 是否降序排列
- 批量操作状态：isBulkOperating, bulkOperationProgress, bulkOperationType

### 关键方法

- `initialize()` - 初始化Vibe库，有守卫防止重复加载
- `reload()` - 重新加载数据
- `loadPage()` - 分页加载
- `_applyFilters()` - 应用搜索和过滤
- `saveEntry()` / `deleteEntry()` - 条目CRUD操作
- `saveCategory()` / `deleteCategory()` - 分类CRUD操作
- 批量操作方法：bulkDelete, bulkMove, bulkExport, bulkEditTags

### Provider结构

```dart
@Riverpod(keepAlive: true)  // ✅ 正确，需要全局保持
class VibeLibraryNotifier extends _$VibeLibraryNotifier {
  late final VibeLibraryStorageService _storage;

  @override
  VibeLibraryState build() {
    _storage = ref.watch(vibeLibraryStorageServiceProvider);
    return const VibeLibraryState();
  }
  // ...
}
```

### 结论

这是Riverpod中`keepAlive`的典型用例：
- 活跃/进行中的工作 - 支持批量操作
- 重要的用户数据 - Vibe库是用户资产
- 昂贵的初始化 - 需要从存储加载数据
- 状态持续性 - 用户期望过滤器/搜索保持

**状态**: 已验证，当前配置正确，无需代码修改。

### 提交信息
```
auto-claude: subtask-6-4 - 评估vibe_library_provider - 保留keepAlive
```

### 状态
✅ 已完成 - 2026-02-16

---

